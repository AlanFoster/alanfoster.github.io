---
layout: post
title:  Compiler Notes
date:   2012-01-28 09:33:53
category: post
---

When writing a compiler, the general high level stages are followed:

```
           __________            __________            ______________
  Source  |          |  Tokens  |          |  Parse   |             | Compiled
--------->| Lexical  | -------> | Parsing  |--------->|    Code     |---------->
   Code   | Analysis |          |          |   Tree   |  Generation |  Code
          |__________|          |__________|          |_____________|
                                                      ^              ^
                                                      ~~~Optimizing~~~
```

## Lexical Analysis

The raw source code is input, and produced are tokens. A token consists of
two parts:

- A token type
- The text matched - referred as the literal value, or a 'Lexeme'

For instance, given the input file:

```
let helloWorld = "hello world";
let sum = 1 + 2 / 2;
```

The sequence of tokens generated, in JSON format, may resemble:

```json
[
  {"type": "IDENTIFIER", "literal": "helloWorld"},
  {"type": "=", "literal": "="},
  {"type": "STRING", "literal": "hello world"},
  {"type": ";", "literal": ";"}
]
```

Token types may include:
- Number
- String
- Punctuation
- Operators
- Various Keywords

### Whitespace

Often whitespace tokens are intentionally omitted as part of the lexical analysis
stage within compilers, as white space is not significant.

For languages that have syntactically significant whitespace, such as Python,
CoffeeScript, etc. the lexer can emit specific tokens for this scenario:

```JSON
{"type": "{", "literal": "{"},
{"type": "INDENT", "literal": "\n\n\n\n"},
{"type": "}", "literal": "}"},
{"type": "DEDENT", "literal": "\n\n"},
```

In this scenario, a lexer will need to keep track of the current indentation value, and
emit tokens as appropriate.

Additionally some code quality tools may also require the the use whitespace tokens for linting purposes.

## Parsing

### Role

Converts a sequence of tokens generated by the Lexer into into a _parse tree_ or _astract syntax tree_.
Generally there will be a buffer of tokens that the parser may have access to at one time, of length _k_.

### Terminology:

## LL

- The first _L_ stands for left to right scanning
- The second _L_ stands for using a left most derivation

### LR

- The first _L_ stands for left to right scanning
- The _R_ stands for following a right most derivation

### LL(K)

- The first _L_ stands for left to right scanning
- The _R_ stands for following a right most derivation
- The K represents how many tokens of lookahead are required, frequently 1. i.e. LL(1)

## Code Generation
